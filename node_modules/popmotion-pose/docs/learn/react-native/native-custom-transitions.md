---
title: Custom transitions
description: How to use React Animated to define custom transitions for posers
category: react-native
next: native-animating-children
---

# Custom transitions

By default, Pose figures out what animations to use based on the style properties defined on them.

But, there's plenty of instances where we want full control over the animation used. For this we can use the `transition` property.

<TOC />

## transition

Just like CSS, every pose has an optional `transition` property. It's a function that creates a React Animated animation (or returns `false`, for instant transition).

```javascript
import { Animated } from 'react-native';

const slowTween = ({ value, toValue, useNativeDriver }) =>
  Animated.timing(value, {
    toValue,
    useNativeDriver,
    duration: 1500,
  });

const config = {
  visible: { opacity: 1, transition: slowTween },
  hidden: { opacity: 0, transition: () => false }
};
```

<Video src="/static/videos/native-custom-transition.mp4" height="320" />

The `transition` function is run **once, for every value in the current pose**. This allows you to return a different animation for each value based on the provided `key` property:

```javascript
const config = {
  visible: {
    opacity: 1,
    y: 0,
    transition: ({ value, toValue, useNativeDriver, key }) => {
      switch(key) {
        case 'opacity':
          return Animated.timing(value, { toValue, useNativeDriver })
        case 'y':
          return Animated.spring(value, { toValue, useNativeDriver })
      }
    }
  },
  hidden: { opacity: 0, y: -50 }
}
```

<Video src="/static/videos/native-custom-transition-b.mp4" height="320" />

## transition props

So far we've seen that the `transition` function accepts a single argument of props. `props` consists of properties generated by both Pose and defined by the posed component:

### Pose-generated props

The following props are provided by Pose:

- `value`: The `Animated.Value` for this animating value - you **must** provide this to the returned animation.
- `toValue`: This is the target defined by the pose. You can optionally provide this to the returned animation.
- `useNativeDriver`: Pose automatically manages whether you can use the native driver on a specific property. Making a component draggable, or using a `passive` value that isn't a transform or `opacity` will make `useNativeDriver` `false`.
- `key`: The name of the value being animated.
- `prevPoseKey`: The name of the pose this value was previously set to.

### Component-defined props

The `props` object will also contain any props passed to the posed component.

For instance, if we're rendering items in a loop, we could pass the loop index to each component as `i` and change the returned animation based on that:

```javascript
const BASE_DURATION = 100;

const config = {
  open: {
    scaleX: 1,
    transition: ({ i, value, toValue, useNativeDriver }) =>
      Animated.timing(value, {
        toValue,
        useNativeDriver,
        duration: (i + 1) * BASE_DURATION
      })
  },
  closed: { scaleX: 0 }
};

export default ({ items, isOpen }) => items.map((item, i) => (
  <Item pose={isOpen ? 'open' : 'closed'} i={i} />
))
```

<Video src="/static/videos/native-custom-transition-c.mp4" height="320" />

## Dynamic pose props

Every property set on a pose can be set as a function that will only resolve when the pose is entered.

These functions get passed all the same component-defined `props` as `transition`.

For instance, we could define a `closed` animation where each item is offset further away based on the `i` prop from before:

```javascript
closed: {
  opacity: 0,
  y: ({ i }) => i * 50
}
```

<Video src="/static/videos/native-custom-transition-d.mp4" height="320" />

## Looping and sequencing animations

In the near future, there may be a `loop` property that automatically loops any returned animations. But, because `transition` can return any React Animated animation, we can already implement looping and sequencing.

For instance, we might want to animate a continuous throbbing animation using `scale`. Like Popmotion, React Animated has a composable API, so we can simply use `loop` in combination with `sequence`:

```javascript
const config = {
  alert: {
    scale: 1.3,
    transition: ({ value, toValue, useNativeDriver }) => Animated.loop(
      Animated.sequence([
        Animated.timing(value, { toValue, useNativeDriver, duration: 400 }),
        Animated.timing(value, { toValue: 1, useNativeDriver, duration: 400 })
      ])
    )
  }
}
```

<Video src="/static/videos/native-custom-transition-e.mp4" height="320" />
